---
layout: post
title: OCaml 시험대비 정리
date: 2025-09-21 14:46 +0200
categories: [Programming Language, OCaml]
tags: [ocaml, fpv]
---

# OCaml

시험을 앞두고, 시험 중에 요긴하게 쓰일만한 내용들을 따로 정리해둔다. 안그럼 돌아서면 까먹고, 누우면 까먹고 그런 상태라..


## List Modules

### List.fold_left

- List.fold_left는 리스트의 요소들을 처음부터 끝까지 훑으면서 하나의 값으로 합쳐나갑니다.
- 숫자 리스트의 총합이나 평균을 구할 때
- 리스트에서 가장 크거나 작은 값을 찾을 때
- 특정 조건을 만족하는 요소의 개수를 셀 때

```ocaml
let prices = [1500; 3000; 2500]
(* 0원(초기값)에서 시작해서, 가격을 차례대로 더해나간다 *)
let total_price = List.fold_left (+) 0 prices (* 결과: 7000 *)
```


### List.map

- List.map은 리스트의 모든 요소에 똑같은 작업을 해서 새로운 리스트를 만듭니다. 리스트의 길이는 변하지 않습니다.
- 숫자 리스트의 모든 값을 두 배로 만들 때
- 문자열 리스트의 모든 단어를 대문자로 바꿀 때
- 사용자 객체 리스트에서 사용자 이름만 뽑아 리스트를 만들 때

```ocaml
let scores = [80; 95; 72]
let bonus_scores = List.map (fun score -> score + 5) scores
```


### List.flatten

- List.flatten은 여러 겹으로 포장된 리스트를 한 겹의 평평한 리스트로 만들어줍니다.
- map을 사용한 결과가 리스트의 리스트일 때 이를 하나로 합치고 싶을 때 (예: 각 문장(리스트)에서 단어(리스트)를 뽑아 전체 단어 목록을 만들 때)
- 여러 출처에서 가져온 데이터 목록들을 단일 목록으로 병합할 때

```ocaml
let class_A = ["철수"; "영희"]
let class_B = ["민준"]
let class_C = ["수빈"; "지아"; "현우"]
let all_students = List.flatten [class_A; class_B; class_C]
(* 결과: ["철수"; "영희"; "민준"; "수빈"; "지아"; "현우"] *)
```

### List.find

리스트에서 특정 조건을 만족하는 첫 번째 원소를 찾아주는 함수

```ocaml
(* 리스트 [1; 3; 4; 5; 6] 에서 첫 번째 짝수를 찾아라 *)
List.find (fun x -> x mod 2 = 0) [1; 3; 4; 5; 6];;
```

### List.for_all

리스트의 모든 원소가 특정 조건을 만족하는지 확인해서 true 또는 false를 반환하는 함수

```ocaml
(* 리스트 [10; 5; 22; 1] 의 모든 원소가 0보다 큰가? *)
List.for_all (fun x -> x > 0) [10; 5; 22; 1];;
```

```ocaml
(* 리스트 [10; -5; 22; 1] 의 모든 원소가 0보다 큰가? *)
List.for_all (fun x -> x > 0) [10; -5; 22; 1];;
```

for_all은 10을 확인하고, 그 다음 -5를 확인합니다. -5는 0보다 크지 않으므로 조건을 만족하지 못합니다. for_all은 즉시 false를 반환하고 검사를 멈춥니다.



## Tree

## Tail-Recursive

일단 helper 함수 선언하고, 베이스 케이스를 만들 것! 


### Example 1

```ocaml
type tree = Leaf of int | Node of int * tree * tree

let rec sum_tree t =
  match t with
  | Leaf n -> n
  | Node (n, left, right) -> n + sum_tree left + sum_tree right
```

```ocaml
let sum_tree_tr tree =
  let rec helper acc tr =
    match tr with
    | [] -> acc
    | t :: ts -> (
        match t with
        | Leaf n -> helper (n + acc) ts
        | Node (n, l, r) -> helper (n + acc) (l :: r :: ts))
  in
  helper 0 [ tree ]
```

### Example 2

```ocaml
let rec map_acc f z = function
  | [] -> z, []
  | x :: xs ->
      let z, xs = map_acc f z xs in
      let z, x = f z x in
      z, x::xs
```

```ocaml
let map_acc_tr f z list =
  let rec reverse xs ys = match xs with
  | [] -> ys
  | x::xs -> reverse xs (x::ys) in
  let rec map_helper f z list acc = match list with
  | [] -> z, acc
  | x::xs -> 
    let z, x = f z x in
    map_helper f z xs (x::acc)
  in 
  let reversed = reverse list [] in
  map_helper f z reversed []
```

## Modules



## Functors